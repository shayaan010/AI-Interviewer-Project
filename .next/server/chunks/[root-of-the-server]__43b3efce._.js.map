{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///Users/shazlimekrani/Desktop/project/spur_v7/AI-Interview-Prep-Platform-PrepWise/firebase/admin.ts"],"sourcesContent":["import admin from \"firebase-admin\";\nimport fs from 'fs';\nimport path from 'path';\n\nlet app: admin.app.App;\n\nif (!admin.apps.length) {\n  try {\n    // Check for different ways to configure Firebase Admin\n    let credential: admin.credential.Credential;\n    let storageBucket: string;\n\n    // Method 1: Use GOOGLE_APPLICATION_CREDENTIALS environment variable\n    if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {\n      console.log(`[Firebase Admin] Using service account from GOOGLE_APPLICATION_CREDENTIALS`);\n      \n      const serviceAccountPath = path.resolve(process.env.GOOGLE_APPLICATION_CREDENTIALS);\n      const serviceAccountContent = fs.readFileSync(serviceAccountPath, 'utf8');\n      const serviceAccount = JSON.parse(serviceAccountContent);\n      \n      credential = admin.credential.cert(serviceAccount);\n      // Try multiple bucket naming conventions\n      const possibleBuckets = [\n        process.env.FIREBASE_STORAGE_BUCKET,\n        `${serviceAccount.project_id}.appspot.com`,\n        `${serviceAccount.project_id}.firebasestorage.app`,\n        serviceAccount.project_id\n      ].filter(Boolean);\n      \n      storageBucket = possibleBuckets[0] as string;\n    }\n    // Method 2: Fallback to hardcoded service account file\n    else {\n      console.log(`[Firebase Admin] Using fallback service account file`);\n      const serviceAccountPath = path.join(process.cwd(), \"ai-interview-prep-36e64-firebase-adminsdk-fbsvc-1400160581.json\");\n      \n      const serviceAccountContent = fs.readFileSync(serviceAccountPath, 'utf8');\n      const serviceAccount = JSON.parse(serviceAccountContent);\n      \n      credential = admin.credential.cert(serviceAccount);\n      // Try multiple bucket naming conventions\n      const possibleBuckets = [\n        process.env.FIREBASE_STORAGE_BUCKET,\n        `${serviceAccount.project_id}.appspot.com`,\n        `${serviceAccount.project_id}.firebasestorage.app`,\n        serviceAccount.project_id\n      ].filter(Boolean);\n      \n      storageBucket = possibleBuckets[0] as string;\n    }\n\n    // Initialize the app\n    app = admin.initializeApp({\n      credential: credential,\n      storageBucket: storageBucket,\n      projectId: process.env.FIREBASE_PROJECT_ID || 'ai-interview-prep-36e64'\n    });\n    \n    console.log(`[Firebase Admin] SDK initialized successfully. Project: ${app.options.projectId}, Storage bucket: ${storageBucket}`);\n    \n    // Test the connection\n    try {\n      const bucket = app.storage().bucket();\n      console.log(`[Firebase Admin] Storage bucket confirmed: ${bucket.name}`);\n    } catch (bucketError) {\n      console.error(`[Firebase Admin] Storage bucket verification failed:`, bucketError);\n    }\n  } catch (error) {\n    console.error(\"[Firebase Admin] SDK initialization failed:\", error);\n    throw new Error(`Failed to initialize Firebase Admin SDK: ${(error as Error).message}`);\n  }\n} else {\n  app = admin.app();\n  console.log(\"[Firebase Admin] Using existing app instance.\");\n}\n\n// Export auth, firestore, and storage\nexport const auth = admin.auth(app);\nexport const db = admin.firestore(app);\nexport const storage = admin.storage(app);"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;;;;AAEA,IAAI;AAEJ,IAAI,CAAC,2HAAA,CAAA,UAAK,CAAC,IAAI,CAAC,MAAM,EAAE;IACtB,IAAI;QACF,uDAAuD;QACvD,IAAI;QACJ,IAAI;QAEJ,oEAAoE;QACpE,IAAI,QAAQ,GAAG,CAAC,8BAA8B,EAAE;YAC9C,QAAQ,GAAG,CAAC,CAAC,0EAA0E,CAAC;YAExF,MAAM,qBAAqB,iGAAA,CAAA,UAAI,CAAC,OAAO,CAAC,QAAQ,GAAG,CAAC,8BAA8B;YAClF,MAAM,wBAAwB,6FAAA,CAAA,UAAE,CAAC,YAAY,CAAC,oBAAoB;YAClE,MAAM,iBAAiB,KAAK,KAAK,CAAC;YAElC,aAAa,2HAAA,CAAA,UAAK,CAAC,UAAU,CAAC,IAAI,CAAC;YACnC,yCAAyC;YACzC,MAAM,kBAAkB;gBACtB,QAAQ,GAAG,CAAC,uBAAuB;gBACnC,GAAG,eAAe,UAAU,CAAC,YAAY,CAAC;gBAC1C,GAAG,eAAe,UAAU,CAAC,oBAAoB,CAAC;gBAClD,eAAe,UAAU;aAC1B,CAAC,MAAM,CAAC;YAET,gBAAgB,eAAe,CAAC,EAAE;QACpC,OAEK;YACH,QAAQ,GAAG,CAAC,CAAC,oDAAoD,CAAC;YAClE,MAAM,qBAAqB,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;YAEpD,MAAM,wBAAwB,6FAAA,CAAA,UAAE,CAAC,YAAY,CAAC,oBAAoB;YAClE,MAAM,iBAAiB,KAAK,KAAK,CAAC;YAElC,aAAa,2HAAA,CAAA,UAAK,CAAC,UAAU,CAAC,IAAI,CAAC;YACnC,yCAAyC;YACzC,MAAM,kBAAkB;gBACtB,QAAQ,GAAG,CAAC,uBAAuB;gBACnC,GAAG,eAAe,UAAU,CAAC,YAAY,CAAC;gBAC1C,GAAG,eAAe,UAAU,CAAC,oBAAoB,CAAC;gBAClD,eAAe,UAAU;aAC1B,CAAC,MAAM,CAAC;YAET,gBAAgB,eAAe,CAAC,EAAE;QACpC;QAEA,qBAAqB;QACrB,MAAM,2HAAA,CAAA,UAAK,CAAC,aAAa,CAAC;YACxB,YAAY;YACZ,eAAe;YACf,WAAW,QAAQ,GAAG,CAAC,mBAAmB,IAAI;QAChD;QAEA,QAAQ,GAAG,CAAC,CAAC,wDAAwD,EAAE,IAAI,OAAO,CAAC,SAAS,CAAC,kBAAkB,EAAE,eAAe;QAEhI,sBAAsB;QACtB,IAAI;YACF,MAAM,SAAS,IAAI,OAAO,GAAG,MAAM;YACnC,QAAQ,GAAG,CAAC,CAAC,2CAA2C,EAAE,OAAO,IAAI,EAAE;QACzE,EAAE,OAAO,aAAa;YACpB,QAAQ,KAAK,CAAC,CAAC,oDAAoD,CAAC,EAAE;QACxE;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+CAA+C;QAC7D,MAAM,IAAI,MAAM,CAAC,yCAAyC,EAAE,AAAC,MAAgB,OAAO,EAAE;IACxF;AACF,OAAO;IACL,MAAM,2HAAA,CAAA,UAAK,CAAC,GAAG;IACf,QAAQ,GAAG,CAAC;AACd;AAGO,MAAM,OAAO,2HAAA,CAAA,UAAK,CAAC,IAAI,CAAC;AACxB,MAAM,KAAK,2HAAA,CAAA,UAAK,CAAC,SAAS,CAAC;AAC3B,MAAM,UAAU,2HAAA,CAAA,UAAK,CAAC,OAAO,CAAC","debugId":null}},
    {"offset": {"line": 162, "column": 0}, "map": {"version":3,"sources":["file:///Users/shazlimekrani/Desktop/project/spur_v7/AI-Interview-Prep-Platform-PrepWise/lib/actions/auth.actions.ts"],"sourcesContent":["'use server';\n\nimport { auth, db } from \"@/firebase/admin\";\nimport { cookies } from \"next/headers\";\n\n\n// Session duration (1 week)\nconst SESSION_DURATION = 60 * 60 * 24 * 7;\n\n// Set session cookie\nexport async function setSessionCookie(idToken: string) {\n  if (!auth) {\n    console.error(\"Error setting session cookie: Firebase Admin SDK not initialized.\");\n    return false;\n  }\n  try {\n    const cookieStore = await cookies();\n\n    console.log(\"Creating session cookie from idToken (first 10 chars):\", idToken.substring(0, 10) + \"...\");\n    \n    // Verify the ID token first\n    try {\n      const decodedToken = await auth.verifyIdToken(idToken);\n      console.log(\"ID token verified. User UID:\", decodedToken.uid);\n      console.log(\"ID token audience:\", decodedToken.aud);\n      console.log(\"ID token issuer:\", decodedToken.iss);\n    } catch (verifyError) {\n      console.error(\"Error verifying ID token:\", verifyError);\n      return false;\n    }\n    \n    // Create session cookie\n    const sessionCookie = await auth.createSessionCookie(idToken, {\n      expiresIn: SESSION_DURATION * 1000, // milliseconds\n    });\n\n    console.log(\"Session cookie created successfully\");\n\n    // Set cookie in the browser\n    cookieStore.set(\"session\", sessionCookie, {\n      maxAge: SESSION_DURATION,\n      httpOnly: true,\n      secure: process.env.NODE_ENV === \"production\",\n      path: \"/\",\n      sameSite: \"lax\",\n    });\n    \n    return true;\n  } catch (error) {\n    console.error(\"Error setting session cookie:\", error);\n    return false;\n  }\n}\n\nexport async function signUp(params: SignUpParams) {\n  const { uid, name, email, password } = params;\n\n  if (!db) {\n    console.error(\"Sign-up error: Firebase Admin SDK (Firestore) not initialized.\");\n    return {\n      success: false,\n      message: \"Server database error. Please try again later.\"\n    };\n  }\n\n  try {\n    // check if user exists in db\n    const userRecord = await db.collection(\"users\").doc(uid).get();\n    if (userRecord.exists)\n      return {\n        success: false,\n        message: \"User already exists. Please sign in.\",\n      };\n    // save user to db\n    await db.collection(\"users\").doc(uid).set({\n      name,\n      email,\n      // profileURL,\n      // resumeURL,\n    });\n\n    // Get the ID token to set session cookie\n    // Note: password is not needed here as auth is already handled by Firebase client\n    // but we keep it in the params to match the interface\n\n    return {\n      success: true,\n      message: \"Account created successfully. Please sign in.\",\n    };\n  } catch (error: any) {\n    console.error(\"Error creating user\", error);\n\n    // Handle Firebase specific errors\n    if (error.code === \"auth/email-already-exists\") {\n      return {\n        success: false,\n        message: \"This email is already in use\",\n      };\n    } else if (error.code === \"auth/invalid-email\") {\n      return {\n        success: false,\n        message: \"The email address is not valid\",\n      };\n    } else if (error.code === \"auth/operation-not-allowed\") {\n      return {\n        success: false,\n        message: \"Email/password accounts are not enabled\",\n      };\n    } else if (error.code === \"auth/uid-already-exists\") {\n      return {\n        success: false,\n        message: \"The provided user ID is already in use\",\n      };\n    }\n\n    return {\n      success: false,\n      message: \"Failed to create account. Please try again.\",\n    };\n  }\n}\n\nexport async function signIn(params: SignInParams) {\n  const { email, idToken } = params;\n\n  if (!auth) {\n    console.error(\"Sign-in error: Firebase Admin SDK not initialized.\");\n    return {\n      success: false,\n      message: \"Server authentication error. Please try again later.\"\n    };\n  }\n\n  try {\n    if (!idToken) {\n      console.error(\"Sign-in error: No ID token provided\");\n      return {\n        success: false,\n        message: \"Authentication failed. Please try again.\"\n      };\n    }\n\n    console.log(\"Verifying user email:\", email);\n    const userRecord = await auth.getUserByEmail(email);\n    if (!userRecord) {\n      console.error(\"Sign-in error: User not found for email:\", email);\n      return {\n        success: false,\n        message: \"User does not exist. Create an account.\",\n      };\n    }\n\n    // Clear any existing session cookies first\n    const cookieStore = await cookies();\n    cookieStore.delete(\"session\");\n    console.log(\"Cleared existing session cookies\");\n\n    console.log(\"Setting session cookie for user:\", userRecord.uid);\n    const cookieSet = await setSessionCookie(idToken);\n    \n    if (!cookieSet) {\n      console.error(\"Failed to set session cookie\");\n      return {\n        success: false,\n        message: \"Failed to create session. Please try again.\"\n      };\n    }\n    \n    console.log(\"Sign-in successful for user:\", userRecord.uid);\n    return {\n      success: true,\n      message: \"Signed in successfully.\"\n    };\n    \n  } catch (error: any) {\n    console.error(\"Sign-in error:\", error);\n    \n    // Handle specific Firebase auth error codes\n    if (error.code === \"auth/user-not-found\") {\n      return {\n        success: false,\n        message: \"User not found. Please create an account.\"\n      };\n    } else if (error.code === \"auth/invalid-credential\") {\n      return {\n        success: false,\n        message: \"Invalid credentials. Please try again.\"\n      };\n    } else if (error.code === \"auth/id-token-expired\") {\n      return {\n        success: false,\n        message: \"Your session has expired. Please sign in again.\"\n      };\n    } else if (error.code === \"auth/id-token-revoked\") {\n      return {\n        success: false,\n        message: \"Your session has been revoked. Please sign in again.\"\n      };\n    } else if (error.code === \"auth/invalid-id-token\") {\n      return {\n        success: false,\n        message: \"Invalid authentication token. Please try again.\"\n      };\n    }\n\n    return {\n      success: false,\n      message: \"Failed to log into account. Please try again.\",\n    };\n  }\n}\n\n// Sign out user by clearing the session cookie\nexport async function signOut() {\n  const cookieStore = await cookies();\n\n  cookieStore.delete(\"session\");\n}\n\n// Get current user from session cookie\nexport async function getCurrentUser(): Promise<User | null> {\n  if (!auth || !db) { // Added db check here\n    console.error(\"[getCurrentUser] Error: Firebase Admin SDK (Auth or Firestore) not initialized.\");\n    return null;\n  }\n  const cookieStore = await cookies();\n  const sessionCookie = cookieStore.get('session')?.value;\n\n  console.log(\"[getCurrentUser] Attempting to get session cookie. Value:\", sessionCookie ? \"Exists\" : \"Not Found\");\n\n  if (!sessionCookie) {\n    console.log(\"[getCurrentUser] No session cookie found.\");\n    return null;\n  }\n\n  try {\n    console.log(\"[getCurrentUser] Verifying session cookie...\");\n    // Get project ID safely\n    let projectId = \"unknown\";\n    try {\n      projectId = (auth as any).app.options?.projectId || \"unknown\";\n    } catch (e) {\n      console.log(\"[getCurrentUser] Could not access project ID:\", e);\n    }\n    console.log(\"[getCurrentUser] Auth project ID:\", projectId);\n    \n    try {\n      // First try to decode the session cookie without verification to see what's in it\n      const parts = sessionCookie.split('.');\n      if (parts.length === 3) {\n        const decoded = JSON.parse(Buffer.from(parts[1], 'base64').toString());\n        console.log(\"[getCurrentUser] Session cookie audience:\", decoded.aud);\n        console.log(\"[getCurrentUser] Session cookie issuer:\", decoded.iss);\n      }\n    } catch (decodeError) {\n      console.log(\"[getCurrentUser] Could not decode session cookie:\", decodeError);\n    }\n    \n    const decodedClaims = await auth.verifySessionCookie(sessionCookie, true); // true checks for revocation\n    console.log(\"[getCurrentUser] Session cookie verified. UID:\", decodedClaims.uid);\n\n    // get user info from db\n    const userRecord = await db\n      .collection(\"users\")\n      .doc(decodedClaims.uid)\n      .get();\n\n    if (!userRecord.exists) {\n      console.log(\"[getCurrentUser] User not found in Firestore DB for UID:\", decodedClaims.uid);\n      return null;\n    }\n\n    console.log(\"[getCurrentUser] User found in Firestore DB. Email:\", userRecord.data()?.email);\n    return {\n      ...userRecord.data(),\n      id: userRecord.id,\n    } as User;\n  } catch (error) {\n    console.error(\"[getCurrentUser] Error verifying session cookie or fetching user:\", error instanceof Error ? error.message : String(error));\n    if (typeof error === 'object' && error !== null && 'code' in error) {\n      console.error(\"[getCurrentUser] Error code:\", (error as {code: string}).code);\n    }\n    // Invalid or expired session\n    return null;\n  }\n}\n\n// Check if user is authenticated\nexport async function isAuthenticated() {\n  console.log(\"[isAuthenticated] Checking authentication status...\");\n  const user = await getCurrentUser();\n  console.log(\"[isAuthenticated] User object:\", user ? `Exists (ID: ${user.id})` : \"null\");\n  return !!user;\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 457, "column": 0}, "map": {"version":3,"sources":["file:///Users/shazlimekrani/Desktop/project/spur_v7/AI-Interview-Prep-Platform-PrepWise/lib/mongodb.ts"],"sourcesContent":["import { MongoClient, Db } from 'mongodb';\nimport mongoose from 'mongoose';\n\nif (!process.env.MONGODB_URI) {\n  throw new Error('Please add your MongoDB URI to .env.local')\n}\n\nconst uri = process.env.MONGODB_URI;\nconst dbName = process.env.MONGODB_DB_NAME || 'ai-interview-prep';\n\nlet client: MongoClient;\nlet clientPromise: Promise<MongoClient>;\n\nif (process.env.NODE_ENV === 'development') {\n  // In development mode, use a global variable so that the value\n  // is preserved across module reloads caused by HMR (Hot Module Replacement).\n  let globalWithMongo = global as typeof globalThis & {\n    _mongoClientPromise?: Promise<MongoClient>\n  }\n\n  if (!globalWithMongo._mongoClientPromise) {\n    client = new MongoClient(uri);\n    globalWithMongo._mongoClientPromise = client.connect();\n  }\n  clientPromise = globalWithMongo._mongoClientPromise;\n} else {\n  // In production mode, it's best to not use a global variable.\n  client = new MongoClient(uri);\n  clientPromise = client.connect();\n}\n\n// Mongoose connection (for schemas)\nlet mongoose_connection: typeof mongoose | null = null;\n\nexport async function connectToMongoDB() {\n  try {\n    if (mongoose_connection?.connection?.readyState === 1) {\n      return mongoose_connection;\n    }\n\n    console.log('[MongoDB] Connecting to database...');\n    mongoose_connection = await mongoose.connect(uri, {\n      dbName: dbName,\n    });\n    \n    console.log(`[MongoDB] Connected successfully to database: ${dbName}`);\n    return mongoose_connection;\n  } catch (error) {\n    console.error('[MongoDB] Connection failed:', error);\n    throw error;\n  }\n}\n\n// Get MongoDB client (for direct operations)\nexport async function getMongoClient(): Promise<MongoClient> {\n  return clientPromise;\n}\n\n// Get MongoDB database\nexport async function getDatabase(): Promise<Db> {\n  const client = await getMongoClient();\n  return client.db(dbName);\n}\n\n// Close connection\nexport async function closeConnection() {\n  if (mongoose_connection) {\n    await mongoose_connection.disconnect();\n    mongoose_connection = null;\n  }\n  \n  const client = await getMongoClient();\n  await client.close();\n}\n\nexport default clientPromise;\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AAEA,IAAI,CAAC,QAAQ,GAAG,CAAC,WAAW,EAAE;IAC5B,MAAM,IAAI,MAAM;AAClB;AAEA,MAAM,MAAM,QAAQ,GAAG,CAAC,WAAW;AACnC,MAAM,SAAS,QAAQ,GAAG,CAAC,eAAe,IAAI;AAE9C,IAAI;AACJ,IAAI;AAEJ,wCAA4C;IAC1C,+DAA+D;IAC/D,6EAA6E;IAC7E,IAAI,kBAAkB;IAItB,IAAI,CAAC,gBAAgB,mBAAmB,EAAE;QACxC,SAAS,IAAI,uGAAA,CAAA,cAAW,CAAC;QACzB,gBAAgB,mBAAmB,GAAG,OAAO,OAAO;IACtD;IACA,gBAAgB,gBAAgB,mBAAmB;AACrD,OAAO;;AAIP;AAEA,oCAAoC;AACpC,IAAI,sBAA8C;AAE3C,eAAe;IACpB,IAAI;QACF,IAAI,qBAAqB,YAAY,eAAe,GAAG;YACrD,OAAO;QACT;QAEA,QAAQ,GAAG,CAAC;QACZ,sBAAsB,MAAM,yGAAA,CAAA,UAAQ,CAAC,OAAO,CAAC,KAAK;YAChD,QAAQ;QACV;QAEA,QAAQ,GAAG,CAAC,CAAC,8CAA8C,EAAE,QAAQ;QACrE,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,MAAM;IACR;AACF;AAGO,eAAe;IACpB,OAAO;AACT;AAGO,eAAe;IACpB,MAAM,SAAS,MAAM;IACrB,OAAO,OAAO,EAAE,CAAC;AACnB;AAGO,eAAe;IACpB,IAAI,qBAAqB;QACvB,MAAM,oBAAoB,UAAU;QACpC,sBAAsB;IACxB;IAEA,MAAM,SAAS,MAAM;IACrB,MAAM,OAAO,KAAK;AACpB;uCAEe","debugId":null}},
    {"offset": {"line": 527, "column": 0}, "map": {"version":3,"sources":["file:///Users/shazlimekrani/Desktop/project/spur_v7/AI-Interview-Prep-Platform-PrepWise/lib/models/mongodb-schemas.ts"],"sourcesContent":["import mongoose, { Document, Schema, Model } from 'mongoose';\n\n// Voice Recording Schema\nexport interface IVoiceRecording extends Document {\n  _id: string;\n  userId: string;\n  interviewId: string;\n  recordingUrl: string; // Local path or cloud storage URL\n  encryptionKeyId: string;\n  processingStatus: 'pending' | 'processed' | 'failed';\n  rec_length: number; // Recording length in seconds (integer from visual timer)\n  createdAt: Date;\n  expiresAt: Date;\n  metadata: {\n    duration: number;\n    fileSize: number;\n    mimeType: string;\n    originalFileName?: string;\n    storageType: 'local' | 'firebase' | 'aws' | 'gcp';\n    quality?: string;\n    language?: string;\n    transcription?: string;\n    analysis?: any;\n  };\n}\n\nconst VoiceRecordingSchema = new Schema<IVoiceRecording>({\n  userId: { type: String, required: true, index: true },\n  interviewId: { type: String, required: true, index: true },\n  recordingUrl: { type: String, required: true },\n  encryptionKeyId: { type: String, required: true },\n  processingStatus: { \n    type: String, \n    enum: ['pending', 'processed', 'failed'], \n    default: 'pending',\n    index: true\n  },\n  rec_length: { \n    type: Number, \n    required: true, \n    default: 0,\n    validate: {\n      validator: Number.isInteger,\n      message: 'rec_length must be an integer'\n    }\n  }, // Recording duration from visual timer (integer seconds)\n  createdAt: { type: Date, default: Date.now, index: true },\n  expiresAt: { type: Date, required: true, index: true },\n  metadata: {\n    duration: { type: Number, required: true },\n    fileSize: { type: Number, required: true },\n    mimeType: { type: String, required: true },\n    originalFileName: String,\n    storageType: { \n      type: String, \n      enum: ['local', 'firebase', 'aws', 'gcp'], \n      default: 'local' \n    },\n    quality: String,\n    language: { type: String, default: 'en' },\n    transcription: String,\n    analysis: Schema.Types.Mixed\n  }\n}, {\n  timestamps: true,\n  collection: 'voice_recordings'\n});\n\n// Add indexes for performance\nVoiceRecordingSchema.index({ userId: 1, createdAt: -1 });\nVoiceRecordingSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 }); // TTL index\nVoiceRecordingSchema.index({ processingStatus: 1, createdAt: 1 });\n\n// Encryption Keys Schema\nexport interface IEncryptionKey extends Document {\n  _id: string;\n  algorithm: string;\n  version: number;\n  keyData: string; // Base64 encoded key material\n  createdAt: Date;\n  rotatedAt: Date;\n  isActive: boolean;\n  public: boolean;\n}\n\nconst EncryptionKeySchema = new Schema<IEncryptionKey>({\n  algorithm: { type: String, required: true, default: 'AES-GCM' },\n  version: { type: Number, required: true, default: 1 },\n  keyData: { type: String, required: true },\n  createdAt: { type: Date, default: Date.now },\n  rotatedAt: { type: Date, default: Date.now },\n  isActive: { type: Boolean, default: true },\n  public: { type: Boolean, default: false }\n}, {\n  timestamps: true,\n  collection: 'encryption_keys'\n});\n\n// Voice Analysis Schema\nexport interface IVoiceAnalysis extends Document {\n  _id: string;\n  recordingId: string;\n  userId: string;\n  interviewId: string;\n  analysisType: 'sentiment' | 'transcription' | 'keywords' | 'confidence' | 'pace';\n  results: any;\n  confidence: number;\n  processingTime: number;\n  createdAt: Date;\n}\n\nconst VoiceAnalysisSchema = new Schema<IVoiceAnalysis>({\n  recordingId: { type: String, required: true, index: true },\n  userId: { type: String, required: true, index: true },\n  interviewId: { type: String, required: true, index: true },\n  analysisType: { \n    type: String, \n    enum: ['sentiment', 'transcription', 'keywords', 'confidence', 'pace'],\n    required: true,\n    index: true\n  },\n  results: { type: Schema.Types.Mixed, required: true },\n  confidence: { type: Number, min: 0, max: 1 },\n  processingTime: Number, // milliseconds\n  createdAt: { type: Date, default: Date.now }\n}, {\n  timestamps: true,\n  collection: 'voice_analyses'\n});\n\nVoiceAnalysisSchema.index({ recordingId: 1, analysisType: 1 });\n\n// User Privacy Settings Schema\nexport interface IUserPrivacySettings extends Document {\n  _id: string;\n  userId: string;\n  voiceRecording: {\n    enabled: boolean;\n    autoDelete: boolean;\n    retentionDays: number;\n  };\n  dataSharing: {\n    allowAnalytics: boolean;\n    allowImprovement: boolean;\n    allowThirdParty: boolean;\n  };\n  notifications: {\n    recordingReminders: boolean;\n    dataExpiry: boolean;\n    analysisComplete: boolean;\n  };\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nconst UserPrivacySettingsSchema = new Schema<IUserPrivacySettings>({\n  userId: { type: String, required: true, unique: true, index: true },\n  voiceRecording: {\n    enabled: { type: Boolean, default: true },\n    autoDelete: { type: Boolean, default: true },\n    retentionDays: { type: Number, default: 30, min: 1, max: 365 }\n  },\n  dataSharing: {\n    allowAnalytics: { type: Boolean, default: false },\n    allowImprovement: { type: Boolean, default: false },\n    allowThirdParty: { type: Boolean, default: false }\n  },\n  notifications: {\n    recordingReminders: { type: Boolean, default: true },\n    dataExpiry: { type: Boolean, default: true },\n    analysisComplete: { type: Boolean, default: true }\n  }\n}, {\n  timestamps: true,\n  collection: 'user_privacy_settings'\n});\n\n// Interview Analysis Schema\nexport interface IInterviewAnalysis extends Document {\n  _id: string;\n  recordingId: string;\n  userId: string;\n  interviewId: string;\n  analysis: {\n    clarity: { filler_word_count: number };\n    confidence_metrics: { pitch_stability_score: number };\n    pace: number;\n    transcript?: string;\n    tone?: { label: string; confidence: number };\n    duration_seconds?: number;\n    overallScore?: number;\n    recommendations?: string[];\n  };\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nconst InterviewAnalysisSchema = new Schema<IInterviewAnalysis>({\n  recordingId: { type: String, required: true, index: true },\n  userId: { type: String, required: true, index: true },\n  interviewId: { type: String, required: true, index: true },\n  analysis: {\n    clarity: {\n      filler_word_count: { type: Number, required: true }\n    },\n    confidence_metrics: {\n      pitch_stability_score: { type: Number, required: true }\n    },\n    pace: { type: Number, required: true },\n    transcript: String,\n    tone: {\n      label: String,\n      confidence: Number\n    },\n    duration_seconds: Number,\n    overallScore: Number,\n    recommendations: [String]\n  }\n}, {\n  timestamps: true,\n  collection: 'interview_analyses'\n});\n\nInterviewAnalysisSchema.index({ recordingId: 1 }, { unique: true });\nInterviewAnalysisSchema.index({ userId: 1, createdAt: -1 });\n\n// Create models with proper typing\nexport const VoiceRecording: Model<IVoiceRecording> = mongoose.models.VoiceRecording || mongoose.model<IVoiceRecording>('VoiceRecording', VoiceRecordingSchema);\nexport const EncryptionKey: Model<IEncryptionKey> = mongoose.models.EncryptionKey || mongoose.model<IEncryptionKey>('EncryptionKey', EncryptionKeySchema);\nexport const VoiceAnalysis: Model<IVoiceAnalysis> = mongoose.models.VoiceAnalysis || mongoose.model<IVoiceAnalysis>('VoiceAnalysis', VoiceAnalysisSchema);\nexport const UserPrivacySettings: Model<IUserPrivacySettings> = mongoose.models.UserPrivacySettings || mongoose.model<IUserPrivacySettings>('UserPrivacySettings', UserPrivacySettingsSchema);\nexport const InterviewAnalysis: Model<IInterviewAnalysis> = mongoose.models.InterviewAnalysis || mongoose.model<IInterviewAnalysis>('InterviewAnalysis', InterviewAnalysisSchema);\n\nexport default {\n  VoiceRecording,\n  EncryptionKey,\n  VoiceAnalysis,\n  UserPrivacySettings,\n  InterviewAnalysis\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 858, "column": 0}, "map": {"version":3,"sources":["file:///Users/shazlimekrani/Desktop/project/spur_v7/AI-Interview-Prep-Platform-PrepWise/lib/services/voiceDataServiceMongoDB.ts"],"sourcesContent":["// Voice data storage and encryption service - MongoDB version\n\nimport { connectToMongoDB } from '@/lib/mongodb';\nimport { VoiceRecording, EncryptionKey, VoiceAnalysis, IVoiceRecording, IEncryptionKey } from '@/lib/models/mongodb-schemas';\nimport * as crypto from 'crypto';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Constants\nconst RECORDING_EXPIRY_DAYS = 30;\nconst LOCAL_STORAGE_PATH = path.join(process.cwd(), 'temp', 'encrypted-recordings');\n\n/**\n * Service for handling voice recordings with encryption - MongoDB version\n */\nexport const voiceDataServiceMongoDB = {\n  /**\n   * Store an encrypted voice recording\n   */\n  async storeVoiceRecording(\n    userId: string, \n    interviewId: string, \n    recordingBuffer: Buffer,\n    metadata: { duration: number; fileSize: number; mimeType: string; originalFileName?: string; [key: string]: any }\n  ): Promise<string> {\n    try {\n      await connectToMongoDB();\n\n      // 1. Generate a new encryption key for this recording\n      const { keyId, encryptedData } = await encryptBuffer(recordingBuffer);\n      \n      // 2. Generate a unique filename\n      const filename = `voice-recordings/${userId}/${interviewId}/${crypto.randomUUID()}.enc`;\n      \n      // 3. Store encrypted data (Firebase Storage or local fallback)\n      let fileUrl: string;\n      let storageType: 'local' | 'firebase' = 'local';\n      \n      try {\n        // Try Firebase Storage first (if available)\n        const { storage } = await import('@/firebase/admin');\n        const fileRef = storage.bucket().file(filename);\n        await fileRef.save(encryptedData, {\n          metadata: {\n            contentType: 'application/octet-stream',\n            metadata: {\n              encryptionKeyId: keyId,\n              originalContentType: metadata.mimeType\n            }\n          }\n        });\n        \n        fileUrl = filename;\n        storageType = 'firebase';\n        console.log('[MongoDB Voice Service] Stored in Firebase Storage');\n      } catch (storageError) {\n        console.warn('[MongoDB Voice Service] Firebase Storage failed, using local storage:', storageError);\n        \n        // Fallback to local file system\n        if (!fs.existsSync(LOCAL_STORAGE_PATH)) {\n          fs.mkdirSync(LOCAL_STORAGE_PATH, { recursive: true });\n        }\n        \n        const localFilename = `${crypto.randomUUID()}.enc`;\n        const localPath = path.join(LOCAL_STORAGE_PATH, localFilename);\n        fs.writeFileSync(localPath, encryptedData);\n        \n        fileUrl = `local://${localFilename}`;\n        storageType = 'local';\n        console.log('[MongoDB Voice Service] Stored in local storage');\n      }\n      \n      // 4. Calculate expiry date (30 days from now)\n      const now = new Date();\n      const expiresAt = new Date(now.getTime() + RECORDING_EXPIRY_DAYS * 24 * 60 * 60 * 1000);\n      \n      // 5. Store recording metadata in MongoDB\n      const voiceRecording = new VoiceRecording({\n        userId,\n        interviewId,\n        recordingUrl: fileUrl,\n        encryptionKeyId: keyId,\n        processingStatus: 'pending',\n        createdAt: now,\n        expiresAt: expiresAt,\n        metadata: {\n          ...metadata,\n          originalFileName: metadata.originalFileName,\n          storageType\n        }\n      });\n      \n      const savedRecording = await voiceRecording.save();\n      console.log(`[MongoDB Voice Service] Recording saved with ID: ${savedRecording._id}`);\n      \n      return savedRecording._id.toString();\n    } catch (error) {\n      console.error('[MongoDB Voice Service] Error storing voice recording:', error);\n      throw new Error('Failed to store voice recording');\n    }\n  },\n  \n  /**\n   * Retrieve and decrypt a voice recording\n   */\n  async getVoiceRecording(recordingId: string): Promise<{buffer: Buffer; metadata: IVoiceRecording}> {\n    try {\n      await connectToMongoDB();\n\n      // 1. Get recording metadata from MongoDB\n      const recordingData = await VoiceRecording.findById(recordingId);\n      if (!recordingData) {\n        throw new Error('Recording not found');\n      }\n      \n      // 2. Check if recording has expired\n      if (new Date(recordingData.expiresAt) < new Date()) {\n        throw new Error('Recording has expired and has been deleted');\n      }\n      \n      // 3. Get the file from storage\n      let encryptedBuffer: Buffer;\n      \n      if (recordingData.recordingUrl.startsWith('local://')) {\n        // Local storage\n        const filename = recordingData.recordingUrl.replace('local://', '');\n        const localPath = path.join(LOCAL_STORAGE_PATH, filename);\n        \n        if (!fs.existsSync(localPath)) {\n          throw new Error('Recording file not found in local storage');\n        }\n        \n        encryptedBuffer = fs.readFileSync(localPath);\n        console.log('[MongoDB Voice Service] Retrieved from local storage');\n      } else {\n        // Firebase Storage\n        const { storage } = await import('@/firebase/admin');\n        const fileRef = storage.bucket().file(recordingData.recordingUrl);\n        const [exists] = await fileRef.exists();\n        if (!exists) {\n          throw new Error('Recording file not found in storage');\n        }\n        \n        const [buffer] = await fileRef.download();\n        encryptedBuffer = buffer;\n        console.log('[MongoDB Voice Service] Retrieved from Firebase Storage');\n      }\n      \n      // 4. Get the encryption key and decrypt\n      const decryptedBuffer = await decryptBuffer(encryptedBuffer, recordingData.encryptionKeyId);\n      \n      // 5. Return the decrypted buffer and metadata\n      return {\n        buffer: decryptedBuffer,\n        metadata: recordingData\n      };\n    } catch (error) {\n      console.error('[MongoDB Voice Service] Error retrieving recording:', error);\n      throw new Error('Failed to retrieve voice recording');\n    }\n  },\n  \n  /**\n   * Get all voice recordings for a user\n   */\n  async getUserRecordings(userId: string, limit: number = 50): Promise<IVoiceRecording[]> {\n    try {\n      await connectToMongoDB();\n      \n      const recordings = await VoiceRecording\n        .find({ userId })\n        .sort({ createdAt: -1 })\n        .limit(limit)\n        .lean();\n      \n      return recordings;\n    } catch (error) {\n      console.error('[MongoDB Voice Service] Error fetching user recordings:', error);\n      throw new Error('Failed to fetch user recordings');\n    }\n  },\n\n  /**\n   * Update recording duration for a specific interview\n   */\n  async updateRecordingDuration(interviewId: string, duration: number, userId?: string): Promise<boolean> {\n    try {\n      await connectToMongoDB();\n      \n      // Ensure duration is an integer\n      const integerDuration = Math.floor(duration);\n      console.log(`[MongoDB Voice Service] Updating recording duration for interview: ${interviewId}, duration: ${integerDuration}s (integer)`);\n      \n      // Build query - include userId if provided for additional security\n      const query: any = { interviewId };\n      if (userId) {\n        query.userId = userId;\n        console.log(`[MongoDB Voice Service] Including userId in query for additional security: ${userId}`);\n      }\n      \n      const result = await VoiceRecording.updateOne(\n        query,\n        { $set: { rec_length: integerDuration } }\n      );\n      \n      if (result.matchedCount > 0) {\n        console.log(`[MongoDB Voice Service] ✅ Successfully updated duration for interview: ${interviewId}`);\n        return true;\n      } else {\n        console.warn(`[MongoDB Voice Service] ❌ No recording found for interview: ${interviewId}${userId ? ` and user: ${userId}` : ''}`);\n        return false;\n      }\n    } catch (error) {\n      console.error('[MongoDB Voice Service] Error updating recording duration:', error);\n      throw new Error('Failed to update recording duration');\n    }\n  },\n  \n  /**\n   * Delete a voice recording\n   */\n  async deleteVoiceRecording(recordingId: string, userId: string): Promise<boolean> {\n    try {\n      await connectToMongoDB();\n      \n      // 1. Find the recording\n      const recording = await VoiceRecording.findOne({ _id: recordingId, userId });\n      if (!recording) {\n        throw new Error('Recording not found or unauthorized');\n      }\n      \n      // 2. Delete the file from storage\n      try {\n        if (recording.recordingUrl.startsWith('local://')) {\n          // Local storage\n          const filename = recording.recordingUrl.replace('local://', '');\n          const localPath = path.join(LOCAL_STORAGE_PATH, filename);\n          if (fs.existsSync(localPath)) {\n            fs.unlinkSync(localPath);\n          }\n        } else {\n          // Firebase Storage\n          const { storage } = await import('@/firebase/admin');\n          const fileRef = storage.bucket().file(recording.recordingUrl);\n          await fileRef.delete();\n        }\n      } catch (storageError) {\n        console.warn('[MongoDB Voice Service] Error deleting storage file:', storageError);\n        // Continue with database deletion even if storage deletion fails\n      }\n      \n      // 3. Delete encryption key\n      try {\n        await EncryptionKey.findByIdAndDelete(recording.encryptionKeyId);\n      } catch (keyError) {\n        console.warn('[MongoDB Voice Service] Error deleting encryption key:', keyError);\n      }\n      \n      // 4. Delete recording from database\n      await VoiceRecording.findByIdAndDelete(recordingId);\n      \n      // 5. Delete associated analyses\n      await VoiceAnalysis.deleteMany({ recordingId });\n      \n      console.log(`[MongoDB Voice Service] Recording ${recordingId} deleted successfully`);\n      return true;\n    } catch (error) {\n      console.error('[MongoDB Voice Service] Error deleting recording:', error);\n      throw new Error('Failed to delete voice recording');\n    }\n  },\n  \n  /**\n   * Clean up expired recordings\n   */\n  async cleanupExpiredRecordings(): Promise<number> {\n    try {\n      await connectToMongoDB();\n      \n      const now = new Date();\n      const expiredRecordings = await VoiceRecording.find({ \n        expiresAt: { $lt: now } \n      });\n      \n      let deletedCount = 0;\n      \n      for (const recording of expiredRecordings) {\n        try {\n          await this.deleteVoiceRecording(recording._id.toString(), recording.userId);\n          deletedCount++;\n        } catch (error) {\n          console.error(`[MongoDB Voice Service] Failed to delete expired recording ${recording._id}:`, error);\n        }\n      }\n      \n      console.log(`[MongoDB Voice Service] Cleaned up ${deletedCount} expired recordings`);\n      return deletedCount;\n    } catch (error) {\n      console.error('[MongoDB Voice Service] Error cleaning up expired recordings:', error);\n      throw new Error('Failed to clean up expired recordings');\n    }\n  }\n};\n\n// Helper functions for encryption/decryption (same as before)\n\n/**\n * Encrypt a buffer using AES-GCM\n */\nasync function encryptBuffer(buffer: Buffer): Promise<{ keyId: string; encryptedData: Buffer }> {\n  try {\n    await connectToMongoDB();\n\n    // 1. Generate a new AES-256 key\n    const symmetricKey = crypto.randomBytes(32);\n    const iv = crypto.randomBytes(16);\n    \n    // 2. Encrypt the buffer\n    const cipher = crypto.createCipheriv('aes-256-gcm', symmetricKey, iv);\n    const encrypted = Buffer.concat([cipher.update(buffer), cipher.final()]);\n    const authTag = cipher.getAuthTag();\n    \n    // 3. Store the encryption key in MongoDB\n    const encryptionKey = new EncryptionKey({\n      algorithm: 'AES-GCM',\n      version: 1,\n      keyData: Buffer.concat([symmetricKey, iv]).toString('base64'),\n      createdAt: new Date(),\n      rotatedAt: new Date(),\n      isActive: true,\n      public: false\n    });\n    \n    const savedKey = await encryptionKey.save();\n    \n    // 4. Combine encrypted data with auth tag\n    const encryptedData = Buffer.concat([authTag, encrypted]);\n    \n    return {\n      keyId: savedKey._id.toString(),\n      encryptedData\n    };\n  } catch (error) {\n    console.error('[MongoDB Voice Service] Encryption error:', error);\n    throw new Error('Failed to encrypt data');\n  }\n}\n\n/**\n * Decrypt a buffer using the stored encryption key\n */\nasync function decryptBuffer(encryptedBuffer: Buffer, keyId: string): Promise<Buffer> {\n  try {\n    await connectToMongoDB();\n\n    // 1. Retrieve the encryption key from MongoDB\n    const keyData = await EncryptionKey.findById(keyId);\n    \n    if (!keyData) {\n      throw new Error('Encryption key not found');\n    }\n    \n    if (keyData.algorithm !== 'AES-GCM') {\n      throw new Error(`Unsupported encryption algorithm: ${keyData.algorithm}`);\n    }\n    \n    // 2. Extract key material from stored data\n    const keyMaterial = Buffer.from(keyData.keyData, 'base64');\n    const symmetricKey = keyMaterial.subarray(0, 32);\n    const iv = keyMaterial.subarray(32, 48);\n    \n    // 3. Extract components from encrypted data\n    const authTag = encryptedBuffer.subarray(0, 16);\n    const encrypted = encryptedBuffer.subarray(16);\n    \n    // 4. Set up the decipher\n    const decipher = crypto.createDecipheriv('aes-256-gcm', symmetricKey, iv);\n    decipher.setAuthTag(authTag);\n    \n    // 5. Decrypt the data\n    const decrypted = Buffer.concat([\n      decipher.update(encrypted),\n      decipher.final()\n    ]);\n    \n    return decrypted;\n  } catch (error) {\n    console.error('[MongoDB Voice Service] Decryption error:', error);\n    throw new Error('Failed to decrypt data');\n  }\n}\n\nexport default voiceDataServiceMongoDB;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1208, "column": 0}, "map": {"version":3,"sources":["file:///Users/shazlimekrani/Desktop/project/spur_v7/AI-Interview-Prep-Platform-PrepWise/app/api/user/recordings-mongodb/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { getCurrentUser } from \"@/lib/actions/auth.actions\";\nimport voiceDataServiceMongoDB from \"@/lib/services/voiceDataServiceMongoDB\";\n\n// GET user's voice recordings from MongoDB\nexport async function GET() {\n  try {\n    const user = await getCurrentUser();\n    \n    if (!user) {\n      return NextResponse.json(\n        { success: false, message: \"Unauthorized\" },\n        { status: 401 }\n      );\n    }\n    \n    // Fetch recordings from MongoDB\n    const recordings = await voiceDataServiceMongoDB.getUserRecordings(user.id, 50);\n    \n    // Remove sensitive data\n    const sanitizedRecordings = recordings.map(recording => ({\n      id: recording._id,\n      userId: recording.userId,\n      interviewId: recording.interviewId,\n      processingStatus: recording.processingStatus,\n      rec_length: recording.rec_length || 0, // Include recording duration from visual timer\n      createdAt: recording.createdAt,\n      expiresAt: recording.expiresAt,\n      metadata: {\n        ...recording.metadata,\n        // Remove encryption details from client response\n        encryptionKeyId: undefined\n      }\n    }));\n    \n    return NextResponse.json({ \n      success: true, \n      recordings: sanitizedRecordings,\n      total: recordings.length\n    });\n  } catch (error) {\n    console.error(\"Error fetching recordings from MongoDB:\", error);\n    return NextResponse.json(\n      { success: false, message: \"Failed to fetch recordings\" },\n      { status: 500 }\n    );\n  }\n}\n\n// POST new voice recording to MongoDB\nexport async function POST(request: Request) {\n  try {\n    const user = await getCurrentUser();\n    \n    if (!user) {\n      return NextResponse.json(\n        { success: false, message: \"Unauthorized\" },\n        { status: 401 }\n      );\n    }\n\n    // Get form data with audio file\n    const formData = await request.formData();\n    const audioFile = formData.get('audio') as File;\n    const interviewId = formData.get('interviewId') as string;\n    const metadataStr = formData.get('metadata') as string;\n    \n    if (!audioFile || !interviewId) {\n      return NextResponse.json(\n        { success: false, message: \"Missing audio file or interview ID\" },\n        { status: 400 }\n      );\n    }\n\n    const metadata = metadataStr ? JSON.parse(metadataStr) : {};\n    \n    // Convert file to buffer for encryption\n    const arrayBuffer = await audioFile.arrayBuffer();\n    const audioBuffer = Buffer.from(arrayBuffer);\n    \n    console.log('[MongoDB Recordings API] Processing file upload:', {\n      filename: audioFile.name,\n      size: audioFile.size,\n      type: audioFile.type,\n      interviewId,\n      userId: user.id\n    });\n    \n    // Store the recording using MongoDB voice data service\n    const recordingId = await voiceDataServiceMongoDB.storeVoiceRecording(\n      user.id,\n      interviewId,\n      audioBuffer,\n      {\n        duration: metadata.duration || 0,\n        fileSize: audioFile.size,\n        mimeType: audioFile.type,\n        originalFileName: audioFile.name,\n        ...metadata\n      }\n    );\n    \n    console.log(`[MongoDB Recordings API] Recording stored successfully with ID: ${recordingId}`);\n    \n    return NextResponse.json({ \n      success: true, \n      recordingId,\n      message: \"Recording stored successfully in MongoDB\",\n      storage: \"mongodb\"\n    });\n  } catch (error) {\n    console.error(\"Error storing recording in MongoDB:\", error);\n    return NextResponse.json(\n      { success: false, message: \"Failed to store recording\", error: (error as Error).message },\n      { status: 500 }\n    );\n  }\n}\n\n// DELETE voice recording from MongoDB\nexport async function DELETE(request: Request) {\n  try {\n    const user = await getCurrentUser();\n    \n    if (!user) {\n      return NextResponse.json(\n        { success: false, message: \"Unauthorized\" },\n        { status: 401 }\n      );\n    }\n\n    const { searchParams } = new URL(request.url);\n    const recordingId = searchParams.get('id');\n    \n    if (!recordingId) {\n      return NextResponse.json(\n        { success: false, message: \"Recording ID is required\" },\n        { status: 400 }\n      );\n    }\n    \n    // Delete the recording using MongoDB voice data service\n    const deleted = await voiceDataServiceMongoDB.deleteVoiceRecording(recordingId, user.id);\n    \n    if (!deleted) {\n      return NextResponse.json(\n        { success: false, message: \"Recording not found or unauthorized\" },\n        { status: 404 }\n      );\n    }\n    \n    return NextResponse.json({ \n      success: true, \n      message: \"Recording deleted successfully from MongoDB\"\n    });\n  } catch (error) {\n    console.error(\"Error deleting recording from MongoDB:\", error);\n    return NextResponse.json(\n      { success: false, message: \"Failed to delete recording\", error: (error as Error).message },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}