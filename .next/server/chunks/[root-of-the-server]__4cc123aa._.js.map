{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///Users/shazlimekrani/Desktop/project/spur_v7/AI-Interview-Prep-Platform-PrepWise/firebase/admin.ts"],"sourcesContent":["import admin from \"firebase-admin\";\nimport fs from 'fs';\nimport path from 'path';\n\nlet app: admin.app.App;\n\nif (!admin.apps.length) {\n  try {\n    // Check for different ways to configure Firebase Admin\n    let credential: admin.credential.Credential;\n    let storageBucket: string;\n\n    // Method 1: Use GOOGLE_APPLICATION_CREDENTIALS environment variable\n    if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {\n      console.log(`[Firebase Admin] Using service account from GOOGLE_APPLICATION_CREDENTIALS`);\n      \n      const serviceAccountPath = path.resolve(process.env.GOOGLE_APPLICATION_CREDENTIALS);\n      const serviceAccountContent = fs.readFileSync(serviceAccountPath, 'utf8');\n      const serviceAccount = JSON.parse(serviceAccountContent);\n      \n      credential = admin.credential.cert(serviceAccount);\n      // Try multiple bucket naming conventions\n      const possibleBuckets = [\n        process.env.FIREBASE_STORAGE_BUCKET,\n        `${serviceAccount.project_id}.appspot.com`,\n        `${serviceAccount.project_id}.firebasestorage.app`,\n        serviceAccount.project_id\n      ].filter(Boolean);\n      \n      storageBucket = possibleBuckets[0] as string;\n    }\n    // Method 2: Fallback to hardcoded service account file\n    else {\n      console.log(`[Firebase Admin] Using fallback service account file`);\n      const serviceAccountPath = path.join(process.cwd(), \"ai-interview-prep-36e64-firebase-adminsdk-fbsvc-1400160581.json\");\n      \n      const serviceAccountContent = fs.readFileSync(serviceAccountPath, 'utf8');\n      const serviceAccount = JSON.parse(serviceAccountContent);\n      \n      credential = admin.credential.cert(serviceAccount);\n      // Try multiple bucket naming conventions\n      const possibleBuckets = [\n        process.env.FIREBASE_STORAGE_BUCKET,\n        `${serviceAccount.project_id}.appspot.com`,\n        `${serviceAccount.project_id}.firebasestorage.app`,\n        serviceAccount.project_id\n      ].filter(Boolean);\n      \n      storageBucket = possibleBuckets[0] as string;\n    }\n\n    // Initialize the app\n    app = admin.initializeApp({\n      credential: credential,\n      storageBucket: storageBucket,\n      projectId: process.env.FIREBASE_PROJECT_ID || 'ai-interview-prep-36e64'\n    });\n    \n    console.log(`[Firebase Admin] SDK initialized successfully. Project: ${app.options.projectId}, Storage bucket: ${storageBucket}`);\n    \n    // Test the connection\n    try {\n      const bucket = app.storage().bucket();\n      console.log(`[Firebase Admin] Storage bucket confirmed: ${bucket.name}`);\n    } catch (bucketError) {\n      console.error(`[Firebase Admin] Storage bucket verification failed:`, bucketError);\n    }\n  } catch (error) {\n    console.error(\"[Firebase Admin] SDK initialization failed:\", error);\n    throw new Error(`Failed to initialize Firebase Admin SDK: ${(error as Error).message}`);\n  }\n} else {\n  app = admin.app();\n  console.log(\"[Firebase Admin] Using existing app instance.\");\n}\n\n// Export auth, firestore, and storage\nexport const auth = admin.auth(app);\nexport const db = admin.firestore(app);\nexport const storage = admin.storage(app);"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;;;;AAEA,IAAI;AAEJ,IAAI,CAAC,2HAAA,CAAA,UAAK,CAAC,IAAI,CAAC,MAAM,EAAE;IACtB,IAAI;QACF,uDAAuD;QACvD,IAAI;QACJ,IAAI;QAEJ,oEAAoE;QACpE,IAAI,QAAQ,GAAG,CAAC,8BAA8B,EAAE;YAC9C,QAAQ,GAAG,CAAC,CAAC,0EAA0E,CAAC;YAExF,MAAM,qBAAqB,iGAAA,CAAA,UAAI,CAAC,OAAO,CAAC,QAAQ,GAAG,CAAC,8BAA8B;YAClF,MAAM,wBAAwB,6FAAA,CAAA,UAAE,CAAC,YAAY,CAAC,oBAAoB;YAClE,MAAM,iBAAiB,KAAK,KAAK,CAAC;YAElC,aAAa,2HAAA,CAAA,UAAK,CAAC,UAAU,CAAC,IAAI,CAAC;YACnC,yCAAyC;YACzC,MAAM,kBAAkB;gBACtB,QAAQ,GAAG,CAAC,uBAAuB;gBACnC,GAAG,eAAe,UAAU,CAAC,YAAY,CAAC;gBAC1C,GAAG,eAAe,UAAU,CAAC,oBAAoB,CAAC;gBAClD,eAAe,UAAU;aAC1B,CAAC,MAAM,CAAC;YAET,gBAAgB,eAAe,CAAC,EAAE;QACpC,OAEK;YACH,QAAQ,GAAG,CAAC,CAAC,oDAAoD,CAAC;YAClE,MAAM,qBAAqB,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;YAEpD,MAAM,wBAAwB,6FAAA,CAAA,UAAE,CAAC,YAAY,CAAC,oBAAoB;YAClE,MAAM,iBAAiB,KAAK,KAAK,CAAC;YAElC,aAAa,2HAAA,CAAA,UAAK,CAAC,UAAU,CAAC,IAAI,CAAC;YACnC,yCAAyC;YACzC,MAAM,kBAAkB;gBACtB,QAAQ,GAAG,CAAC,uBAAuB;gBACnC,GAAG,eAAe,UAAU,CAAC,YAAY,CAAC;gBAC1C,GAAG,eAAe,UAAU,CAAC,oBAAoB,CAAC;gBAClD,eAAe,UAAU;aAC1B,CAAC,MAAM,CAAC;YAET,gBAAgB,eAAe,CAAC,EAAE;QACpC;QAEA,qBAAqB;QACrB,MAAM,2HAAA,CAAA,UAAK,CAAC,aAAa,CAAC;YACxB,YAAY;YACZ,eAAe;YACf,WAAW,QAAQ,GAAG,CAAC,mBAAmB,IAAI;QAChD;QAEA,QAAQ,GAAG,CAAC,CAAC,wDAAwD,EAAE,IAAI,OAAO,CAAC,SAAS,CAAC,kBAAkB,EAAE,eAAe;QAEhI,sBAAsB;QACtB,IAAI;YACF,MAAM,SAAS,IAAI,OAAO,GAAG,MAAM;YACnC,QAAQ,GAAG,CAAC,CAAC,2CAA2C,EAAE,OAAO,IAAI,EAAE;QACzE,EAAE,OAAO,aAAa;YACpB,QAAQ,KAAK,CAAC,CAAC,oDAAoD,CAAC,EAAE;QACxE;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+CAA+C;QAC7D,MAAM,IAAI,MAAM,CAAC,yCAAyC,EAAE,AAAC,MAAgB,OAAO,EAAE;IACxF;AACF,OAAO;IACL,MAAM,2HAAA,CAAA,UAAK,CAAC,GAAG;IACf,QAAQ,GAAG,CAAC;AACd;AAGO,MAAM,OAAO,2HAAA,CAAA,UAAK,CAAC,IAAI,CAAC;AACxB,MAAM,KAAK,2HAAA,CAAA,UAAK,CAAC,SAAS,CAAC;AAC3B,MAAM,UAAU,2HAAA,CAAA,UAAK,CAAC,OAAO,CAAC","debugId":null}},
    {"offset": {"line": 162, "column": 0}, "map": {"version":3,"sources":["file:///Users/shazlimekrani/Desktop/project/spur_v7/AI-Interview-Prep-Platform-PrepWise/lib/actions/auth.actions.ts"],"sourcesContent":["'use server';\n\nimport { auth, db } from \"@/firebase/admin\";\nimport { cookies } from \"next/headers\";\n\n\n// Session duration (1 week)\nconst SESSION_DURATION = 60 * 60 * 24 * 7;\n\n// Set session cookie\nexport async function setSessionCookie(idToken: string) {\n  if (!auth) {\n    console.error(\"Error setting session cookie: Firebase Admin SDK not initialized.\");\n    return false;\n  }\n  try {\n    const cookieStore = await cookies();\n\n    console.log(\"Creating session cookie from idToken (first 10 chars):\", idToken.substring(0, 10) + \"...\");\n    \n    // Verify the ID token first\n    try {\n      const decodedToken = await auth.verifyIdToken(idToken);\n      console.log(\"ID token verified. User UID:\", decodedToken.uid);\n      console.log(\"ID token audience:\", decodedToken.aud);\n      console.log(\"ID token issuer:\", decodedToken.iss);\n    } catch (verifyError) {\n      console.error(\"Error verifying ID token:\", verifyError);\n      return false;\n    }\n    \n    // Create session cookie\n    const sessionCookie = await auth.createSessionCookie(idToken, {\n      expiresIn: SESSION_DURATION * 1000, // milliseconds\n    });\n\n    console.log(\"Session cookie created successfully\");\n\n    // Set cookie in the browser\n    cookieStore.set(\"session\", sessionCookie, {\n      maxAge: SESSION_DURATION,\n      httpOnly: true,\n      secure: process.env.NODE_ENV === \"production\",\n      path: \"/\",\n      sameSite: \"lax\",\n    });\n    \n    return true;\n  } catch (error) {\n    console.error(\"Error setting session cookie:\", error);\n    return false;\n  }\n}\n\nexport async function signUp(params: SignUpParams) {\n  const { uid, name, email, password } = params;\n\n  if (!db) {\n    console.error(\"Sign-up error: Firebase Admin SDK (Firestore) not initialized.\");\n    return {\n      success: false,\n      message: \"Server database error. Please try again later.\"\n    };\n  }\n\n  try {\n    // check if user exists in db\n    const userRecord = await db.collection(\"users\").doc(uid).get();\n    if (userRecord.exists)\n      return {\n        success: false,\n        message: \"User already exists. Please sign in.\",\n      };\n    // save user to db\n    await db.collection(\"users\").doc(uid).set({\n      name,\n      email,\n      // profileURL,\n      // resumeURL,\n    });\n\n    // Get the ID token to set session cookie\n    // Note: password is not needed here as auth is already handled by Firebase client\n    // but we keep it in the params to match the interface\n\n    return {\n      success: true,\n      message: \"Account created successfully. Please sign in.\",\n    };\n  } catch (error: any) {\n    console.error(\"Error creating user\", error);\n\n    // Handle Firebase specific errors\n    if (error.code === \"auth/email-already-exists\") {\n      return {\n        success: false,\n        message: \"This email is already in use\",\n      };\n    } else if (error.code === \"auth/invalid-email\") {\n      return {\n        success: false,\n        message: \"The email address is not valid\",\n      };\n    } else if (error.code === \"auth/operation-not-allowed\") {\n      return {\n        success: false,\n        message: \"Email/password accounts are not enabled\",\n      };\n    } else if (error.code === \"auth/uid-already-exists\") {\n      return {\n        success: false,\n        message: \"The provided user ID is already in use\",\n      };\n    }\n\n    return {\n      success: false,\n      message: \"Failed to create account. Please try again.\",\n    };\n  }\n}\n\nexport async function signIn(params: SignInParams) {\n  const { email, idToken } = params;\n\n  if (!auth) {\n    console.error(\"Sign-in error: Firebase Admin SDK not initialized.\");\n    return {\n      success: false,\n      message: \"Server authentication error. Please try again later.\"\n    };\n  }\n\n  try {\n    if (!idToken) {\n      console.error(\"Sign-in error: No ID token provided\");\n      return {\n        success: false,\n        message: \"Authentication failed. Please try again.\"\n      };\n    }\n\n    console.log(\"Verifying user email:\", email);\n    const userRecord = await auth.getUserByEmail(email);\n    if (!userRecord) {\n      console.error(\"Sign-in error: User not found for email:\", email);\n      return {\n        success: false,\n        message: \"User does not exist. Create an account.\",\n      };\n    }\n\n    // Clear any existing session cookies first\n    const cookieStore = await cookies();\n    cookieStore.delete(\"session\");\n    console.log(\"Cleared existing session cookies\");\n\n    console.log(\"Setting session cookie for user:\", userRecord.uid);\n    const cookieSet = await setSessionCookie(idToken);\n    \n    if (!cookieSet) {\n      console.error(\"Failed to set session cookie\");\n      return {\n        success: false,\n        message: \"Failed to create session. Please try again.\"\n      };\n    }\n    \n    console.log(\"Sign-in successful for user:\", userRecord.uid);\n    return {\n      success: true,\n      message: \"Signed in successfully.\"\n    };\n    \n  } catch (error: any) {\n    console.error(\"Sign-in error:\", error);\n    \n    // Handle specific Firebase auth error codes\n    if (error.code === \"auth/user-not-found\") {\n      return {\n        success: false,\n        message: \"User not found. Please create an account.\"\n      };\n    } else if (error.code === \"auth/invalid-credential\") {\n      return {\n        success: false,\n        message: \"Invalid credentials. Please try again.\"\n      };\n    } else if (error.code === \"auth/id-token-expired\") {\n      return {\n        success: false,\n        message: \"Your session has expired. Please sign in again.\"\n      };\n    } else if (error.code === \"auth/id-token-revoked\") {\n      return {\n        success: false,\n        message: \"Your session has been revoked. Please sign in again.\"\n      };\n    } else if (error.code === \"auth/invalid-id-token\") {\n      return {\n        success: false,\n        message: \"Invalid authentication token. Please try again.\"\n      };\n    }\n\n    return {\n      success: false,\n      message: \"Failed to log into account. Please try again.\",\n    };\n  }\n}\n\n// Sign out user by clearing the session cookie\nexport async function signOut() {\n  const cookieStore = await cookies();\n\n  cookieStore.delete(\"session\");\n}\n\n// Get current user from session cookie\nexport async function getCurrentUser(): Promise<User | null> {\n  if (!auth || !db) { // Added db check here\n    console.error(\"[getCurrentUser] Error: Firebase Admin SDK (Auth or Firestore) not initialized.\");\n    return null;\n  }\n  const cookieStore = await cookies();\n  const sessionCookie = cookieStore.get('session')?.value;\n\n  console.log(\"[getCurrentUser] Attempting to get session cookie. Value:\", sessionCookie ? \"Exists\" : \"Not Found\");\n\n  if (!sessionCookie) {\n    console.log(\"[getCurrentUser] No session cookie found.\");\n    return null;\n  }\n\n  try {\n    console.log(\"[getCurrentUser] Verifying session cookie...\");\n    // Get project ID safely\n    let projectId = \"unknown\";\n    try {\n      projectId = (auth as any).app.options?.projectId || \"unknown\";\n    } catch (e) {\n      console.log(\"[getCurrentUser] Could not access project ID:\", e);\n    }\n    console.log(\"[getCurrentUser] Auth project ID:\", projectId);\n    \n    try {\n      // First try to decode the session cookie without verification to see what's in it\n      const parts = sessionCookie.split('.');\n      if (parts.length === 3) {\n        const decoded = JSON.parse(Buffer.from(parts[1], 'base64').toString());\n        console.log(\"[getCurrentUser] Session cookie audience:\", decoded.aud);\n        console.log(\"[getCurrentUser] Session cookie issuer:\", decoded.iss);\n      }\n    } catch (decodeError) {\n      console.log(\"[getCurrentUser] Could not decode session cookie:\", decodeError);\n    }\n    \n    const decodedClaims = await auth.verifySessionCookie(sessionCookie, true); // true checks for revocation\n    console.log(\"[getCurrentUser] Session cookie verified. UID:\", decodedClaims.uid);\n\n    // get user info from db\n    const userRecord = await db\n      .collection(\"users\")\n      .doc(decodedClaims.uid)\n      .get();\n\n    if (!userRecord.exists) {\n      console.log(\"[getCurrentUser] User not found in Firestore DB for UID:\", decodedClaims.uid);\n      return null;\n    }\n\n    console.log(\"[getCurrentUser] User found in Firestore DB. Email:\", userRecord.data()?.email);\n    return {\n      ...userRecord.data(),\n      id: userRecord.id,\n    } as User;\n  } catch (error) {\n    console.error(\"[getCurrentUser] Error verifying session cookie or fetching user:\", error instanceof Error ? error.message : String(error));\n    if (typeof error === 'object' && error !== null && 'code' in error) {\n      console.error(\"[getCurrentUser] Error code:\", (error as {code: string}).code);\n    }\n    // Invalid or expired session\n    return null;\n  }\n}\n\n// Check if user is authenticated\nexport async function isAuthenticated() {\n  console.log(\"[isAuthenticated] Checking authentication status...\");\n  const user = await getCurrentUser();\n  console.log(\"[isAuthenticated] User object:\", user ? `Exists (ID: ${user.id})` : \"null\");\n  return !!user;\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 449, "column": 0}, "map": {"version":3,"sources":["file:///Users/shazlimekrani/Desktop/project/spur_v7/AI-Interview-Prep-Platform-PrepWise/lib/services/voiceDataService.ts"],"sourcesContent":["// Voice data storage and encryption service\n\nimport { db, storage } from '@/firebase/admin';\nimport { EncryptionKey, VoiceRecording, VoiceAnalysis } from '@/types/voiceData';\nimport * as crypto from 'crypto';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Constants\nconst RECORDING_EXPIRY_DAYS = 30;\nconst COLLECTION_RECORDINGS = 'voice_recordings';\nconst COLLECTION_ANALYSES = 'voice_analyses';\nconst COLLECTION_ENCRYPTION_KEYS = 'encryption_keys';\nconst LOCAL_STORAGE_PATH = path.join(process.cwd(), 'temp', 'encrypted-recordings');\n\n/**\n * Service for handling voice recordings with encryption\n */\nexport const voiceDataService = {\n  /**\n   * Store an encrypted voice recording\n   */\n  async storeVoiceRecording(\n    userId: string, \n    interviewId: string, \n    recordingBuffer: Buffer,\n    metadata: { duration: number; fileSize: number; mimeType: string }\n  ): Promise<string> {\n    try {\n      // 1. Generate a new encryption key for this recording\n      const { keyId, encryptedData } = await encryptBuffer(recordingBuffer);\n      \n      // 2. Generate a unique filename\n      const filename = `voice-recordings/${userId}/${interviewId}/${crypto.randomUUID()}.enc`;\n      \n      // 3. Upload encrypted data to Firebase Storage (with fallback to local storage)\n      let fileUrl: string;\n      let isLocalStorage = false;\n      \n      try {\n        const fileRef = storage.bucket().file(filename);\n        await fileRef.save(encryptedData, {\n          metadata: {\n            contentType: 'application/octet-stream', // Always encrypted binary\n            metadata: {\n              encryptionKeyId: keyId,\n              originalContentType: metadata.mimeType\n            }\n          }\n        });\n        \n        // Get signed URL (7 day expiry, for internal use only)\n        const [url] = await fileRef.getSignedUrl({\n          action: 'read',\n          expires: Date.now() + 7 * 24 * 60 * 60 * 1000 // 7 days\n        });\n        \n        fileUrl = filename; // Store the path, not the signed URL\n      } catch (storageError) {\n        console.warn('Firebase Storage failed, using local storage fallback:', storageError);\n        \n        // Fallback to local file system\n        if (!fs.existsSync(LOCAL_STORAGE_PATH)) {\n          fs.mkdirSync(LOCAL_STORAGE_PATH, { recursive: true });\n        }\n        \n        const localFilename = `${crypto.randomUUID()}.enc`;\n        const localPath = path.join(LOCAL_STORAGE_PATH, localFilename);\n        fs.writeFileSync(localPath, encryptedData);\n        \n        fileUrl = `local://${localFilename}`;\n        isLocalStorage = true;\n      }\n      \n      // 4. Calculate expiry date (30 days from now)\n      const now = new Date();\n      const expiresAt = new Date(now.getTime() + RECORDING_EXPIRY_DAYS * 24 * 60 * 60 * 1000);\n      \n      // 5. Store recording metadata in Firestore\n      const recordingData: Omit<VoiceRecording, 'id'> = {\n        userId,\n        interviewId,\n        recordingUrl: fileUrl, // Store the path/URL\n        encryptionKeyId: keyId,\n        processingStatus: 'pending',\n        createdAt: now.toISOString(),\n        expiresAt: expiresAt.toISOString(),\n        metadata: {\n          ...metadata,\n          storageType: isLocalStorage ? 'local' : 'firebase'\n        } as any // Allow additional properties for development\n      };\n      \n      const recordingRef = await db.collection(COLLECTION_RECORDINGS).add(recordingData);\n      \n      // 6. Return recording ID\n      return recordingRef.id;\n    } catch (error) {\n      console.error('Error storing voice recording:', error);\n      throw new Error('Failed to store voice recording');\n    }\n  },\n  \n  /**\n   * Retrieve and decrypt a voice recording\n   */\n  async getVoiceRecording(recordingId: string): Promise<{buffer: Buffer; metadata: VoiceRecording}> {\n    try {\n      // 1. Get recording metadata\n      const recordingDoc = await db.collection(COLLECTION_RECORDINGS).doc(recordingId).get();\n      if (!recordingDoc.exists) {\n        throw new Error('Recording not found');\n      }\n      \n      const recordingData = { id: recordingDoc.id, ...recordingDoc.data() } as VoiceRecording;\n      \n      // 2. Check if recording has expired\n      if (new Date(recordingData.expiresAt) < new Date()) {\n        throw new Error('Recording has expired and has been deleted');\n      }\n      \n      // 3. Get the file from storage\n      let encryptedBuffer: Buffer;\n      \n      if (recordingData.recordingUrl.startsWith('local://')) {\n        // Local storage\n        const filename = recordingData.recordingUrl.replace('local://', '');\n        const localPath = path.join(LOCAL_STORAGE_PATH, filename);\n        \n        if (!fs.existsSync(localPath)) {\n          throw new Error('Recording file not found in local storage');\n        }\n        \n        encryptedBuffer = fs.readFileSync(localPath);\n      } else {\n        // Firebase Storage\n        const fileRef = storage.bucket().file(recordingData.recordingUrl);\n        const [exists] = await fileRef.exists();\n        if (!exists) {\n          throw new Error('Recording file not found in storage');\n        }\n        \n        // 4. Download the encrypted file\n        const [buffer] = await fileRef.download();\n        encryptedBuffer = buffer;\n      }\n      \n      // 5. Get the encryption key and decrypt\n      const decryptedBuffer = await decryptBuffer(encryptedBuffer, recordingData.encryptionKeyId);\n      \n      // 6. Return the decrypted buffer and metadata\n      return {\n        buffer: decryptedBuffer,\n        metadata: recordingData\n      };\n    } catch (error) {\n      console.error('Error retrieving voice recording:', error);\n      throw new Error(`Failed to retrieve voice recording: ${(error as Error).message}`);\n    }\n  },\n  \n  /**\n   * Delete a voice recording (both metadata and file)\n   */\n  async deleteVoiceRecording(recordingId: string, userId: string): Promise<void> {\n    try {\n      // 1. Get recording metadata\n      const recordingRef = db.collection(COLLECTION_RECORDINGS).doc(recordingId);\n      const recordingDoc = await recordingRef.get();\n      \n      if (!recordingDoc.exists) {\n        throw new Error('Recording not found');\n      }\n      \n      const recordingData = recordingDoc.data() as Omit<VoiceRecording, 'id'>;\n      \n      // 2. Verify ownership\n      if (recordingData.userId !== userId) {\n        throw new Error('Not authorized to delete this recording');\n      }\n      \n      // 3. Delete the file from storage\n      const fileRef = storage.bucket().file(recordingData.recordingUrl);\n      await fileRef.delete().catch((err: Error) => {\n        console.warn('Could not delete file from storage:', err);\n        // Continue even if file deletion fails\n      });\n      \n      // 4. Delete recording metadata\n      await recordingRef.delete();\n      \n      // 5. Delete any associated analyses\n      const analysesSnapshot = await db\n        .collection(COLLECTION_ANALYSES)\n        .where('recordingId', '==', recordingId)\n        .get();\n      \n      const batch = db.batch();\n      analysesSnapshot.docs.forEach(doc => {\n        batch.delete(doc.ref);\n      });\n      \n      await batch.commit();\n    } catch (error) {\n      console.error('Error deleting voice recording:', error);\n      throw new Error(`Failed to delete voice recording: ${(error as Error).message}`);\n    }\n  },\n  \n  /**\n   * Set up automatic deletion of expired recordings (called by a scheduled function)\n   */\n  async cleanupExpiredRecordings(): Promise<number> {\n    try {\n      const now = new Date();\n      const expiredRecordings = await db\n        .collection(COLLECTION_RECORDINGS)\n        .where('expiresAt', '<', now.toISOString())\n        .get();\n      \n      if (expiredRecordings.empty) {\n        return 0;\n      }\n      \n      const batch = db.batch();\n      const filesToDelete: string[] = [];\n      \n      expiredRecordings.docs.forEach(doc => {\n        const data = doc.data();\n        filesToDelete.push(data.recordingUrl);\n        batch.delete(doc.ref);\n      });\n      \n      // Delete metadata batch\n      await batch.commit();\n      \n      // Delete files from storage\n      const deletePromises = filesToDelete.map(async filePath => {\n        const fileRef = storage.bucket().file(filePath);\n        return fileRef.delete().catch(() => {\n          // Ignore errors if file doesn't exist\n        });\n      });\n      \n      await Promise.all(deletePromises);\n      \n      return expiredRecordings.size;\n    } catch (error) {\n      console.error('Error cleaning up expired recordings:', error);\n      throw new Error('Failed to clean up expired recordings');\n    }\n  }\n};\n\n// Helper functions for encryption/decryption\n\n/**\n * Encrypt a buffer using quantum-resistant hybrid encryption\n */\nasync function encryptBuffer(buffer: Buffer): Promise<{ keyId: string; encryptedData: Buffer }> {\n  try {\n    // In a real implementation, we'd use a quantum-resistant algorithm\n    // For now, we'll simulate with AES-GCM which is still secure for current threats\n    \n    // 1. Generate a new AES-256 key\n    const symmetricKey = crypto.randomBytes(32);\n    const iv = crypto.randomBytes(16);\n    \n    // 2. Encrypt the buffer\n    const cipher = crypto.createCipheriv('aes-256-gcm', symmetricKey, iv);\n    const encrypted = Buffer.concat([cipher.update(buffer), cipher.final()]);\n    const authTag = cipher.getAuthTag();\n    \n    // 3. Store the encryption key metadata in Firestore\n    const keyData = {\n      algorithm: 'AES-GCM', // In future: 'hybrid' with post-quantum algorithms\n      version: 1,\n      createdAt: new Date().toISOString(),\n      rotatedAt: new Date().toISOString(),\n      public: false,\n      // Store the symmetric key and IV separately from the encrypted data\n      keyData: Buffer.concat([symmetricKey, iv]).toString('base64')\n    };\n    \n    const keyRef = await db.collection(COLLECTION_ENCRYPTION_KEYS).add(keyData);\n    \n    // 4. Combine encrypted data with auth tag\n    // Format: [16-byte Auth Tag][Encrypted Data]\n    const encryptedData = Buffer.concat([authTag, encrypted]);\n    \n    return {\n      keyId: keyRef.id,\n      encryptedData\n    };\n  } catch (error) {\n    console.error('Encryption error:', error);\n    throw new Error('Failed to encrypt data');\n  }\n}\n\n/**\n * Decrypt a buffer using the stored encryption key\n */\nasync function decryptBuffer(encryptedBuffer: Buffer, keyId: string): Promise<Buffer> {\n  try {\n    // 1. Retrieve the encryption key\n    const keyDoc = await db.collection(COLLECTION_ENCRYPTION_KEYS).doc(keyId).get();\n    \n    if (!keyDoc.exists) {\n      throw new Error('Encryption key not found');\n    }\n    \n    const keyData = keyDoc.data() as EncryptionKey;\n    \n    // In a real implementation, we'd check the algorithm and use the appropriate decryption\n    if (keyData.algorithm !== 'AES-GCM') {\n      throw new Error(`Unsupported encryption algorithm: ${keyData.algorithm}`);\n    }\n    \n    // 2. Extract key material from stored data\n    const keyMaterial = Buffer.from(keyData.keyData || '', 'base64');\n    const symmetricKey = keyMaterial.subarray(0, 32);\n    const iv = keyMaterial.subarray(32, 48);\n    \n    // 3. Extract components from encrypted data\n    // Format: [16-byte Auth Tag][Encrypted Data]\n    const authTag = encryptedBuffer.subarray(0, 16);\n    const encrypted = encryptedBuffer.subarray(16);\n    \n    // 4. Set up the decipher\n    const decipher = crypto.createDecipheriv('aes-256-gcm', symmetricKey, iv);\n    decipher.setAuthTag(authTag);\n    \n    // 5. Decrypt the data\n    const decrypted = Buffer.concat([\n      decipher.update(encrypted),\n      decipher.final()\n    ]);\n    \n    return decrypted;\n  } catch (error) {\n    console.error('Decryption error:', error);\n    throw new Error('Failed to decrypt data');\n  }\n}\n\nexport default voiceDataService;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 743, "column": 0}, "map": {"version":3,"sources":["file:///Users/shazlimekrani/Desktop/project/spur_v7/AI-Interview-Prep-Platform-PrepWise/app/api/user/recordings/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { getCurrentUser } from \"@/lib/actions/auth.actions\";\nimport { db } from \"@/firebase/admin\";\nimport voiceDataService from \"@/lib/services/voiceDataService\";\n\n// GET user's voice recordings\nexport async function GET() {\n  try {\n    const user = await getCurrentUser();\n    \n    if (!user) {\n      return NextResponse.json(\n        { success: false, message: \"Unauthorized\" },\n        { status: 401 }\n      );\n    }\n    \n    // Fetch recordings from Firestore\n    const recordingsSnapshot = await db\n      .collection(\"voice_recordings\")\n      .where(\"userId\", \"==\", user.id)\n      .orderBy(\"createdAt\", \"desc\")\n      .limit(50) // Pagination could be implemented\n      .get();\n    \n    const recordings = recordingsSnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data(),\n      // Don't include encryption key details\n      encryptionKeyId: undefined\n    }));\n    \n    return NextResponse.json({ \n      success: true, \n      recordings\n    });\n  } catch (error) {\n    console.error(\"Error fetching recordings:\", error);\n    return NextResponse.json(\n      { success: false, message: \"Failed to fetch recordings\" },\n      { status: 500 }\n    );\n  }\n}\n\n// POST new voice recording (from Vapi call)\nexport async function POST(request: Request) {\n  try {\n    const user = await getCurrentUser();\n    \n    if (!user) {\n      return NextResponse.json(\n        { success: false, message: \"Unauthorized\" },\n        { status: 401 }\n      );\n    }\n\n    // Get form data with audio file\n    const formData = await request.formData();\n    const audioFile = formData.get('audio') as File;\n    const interviewId = formData.get('interviewId') as string;\n    const metadataStr = formData.get('metadata') as string;\n    \n    if (!audioFile || !interviewId) {\n      return NextResponse.json(\n        { success: false, message: \"Missing audio file or interview ID\" },\n        { status: 400 }\n      );\n    }\n\n    const metadata = metadataStr ? JSON.parse(metadataStr) : {};\n    \n    // Convert file to buffer for encryption\n    const arrayBuffer = await audioFile.arrayBuffer();\n    const audioBuffer = Buffer.from(arrayBuffer);\n    \n    // Store the recording using voice data service\n    const recordingId = await voiceDataService.storeVoiceRecording(\n      user.id,\n      interviewId,\n      audioBuffer,\n      {\n        ...metadata,\n        originalFileName: audioFile.name,\n        mimeType: audioFile.type,\n        fileSize: audioFile.size\n      }\n    );\n    \n    return NextResponse.json({ \n      success: true, \n      recordingId,\n      message: \"Recording stored successfully\"\n    });\n  } catch (error) {\n    console.error(\"Error storing recording:\", error);\n    return NextResponse.json(\n      { success: false, message: \"Failed to store recording\" },\n      { status: 500 }\n    );\n  }\n}\nexport async function DELETE(request: Request) {\n  try {\n    const user = await getCurrentUser();\n    \n    if (!user) {\n      return NextResponse.json(\n        { success: false, message: \"Unauthorized\" },\n        { status: 401 }\n      );\n    }\n    \n    // Get the URL to extract parameters\n    const { searchParams } = new URL(request.url);\n    const recordingId = searchParams.get('id');\n    const deleteAll = searchParams.get('all') === 'true';\n    \n    if (deleteAll) {\n      // Find all user recordings\n      const recordingsSnapshot = await db\n        .collection(\"voice_recordings\")\n        .where(\"userId\", \"==\", user.id)\n        .get();\n      \n      // Delete each recording\n      const deletePromises = recordingsSnapshot.docs.map(doc => \n        voiceDataService.deleteVoiceRecording(doc.id, user.id)\n      );\n      \n      await Promise.all(deletePromises);\n      \n      return NextResponse.json({\n        success: true,\n        message: `Successfully deleted ${recordingsSnapshot.size} recordings`\n      });\n    } else if (recordingId) {\n      // Delete a specific recording\n      await voiceDataService.deleteVoiceRecording(recordingId, user.id);\n      \n      return NextResponse.json({\n        success: true,\n        message: \"Recording deleted successfully\"\n      });\n    } else {\n      return NextResponse.json(\n        { success: false, message: \"Missing recording ID or 'all' parameter\" },\n        { status: 400 }\n      );\n    }\n  } catch (error) {\n    console.error(\"Error deleting recordings:\", error);\n    const message = error instanceof Error ? error.message : \"Failed to delete recordings\";\n    \n    return NextResponse.json(\n      { success: false, message },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}